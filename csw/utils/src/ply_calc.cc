
/*
         ************************************************
         *                                              *
         *    Copyright (1997-2017) Glenn Pinkerton.    *
         *    All rights reserved.                      *
         *                                              *
         ************************************************
*/

/*
    file ply_calc.cc

    This file has the bodies of the methods defined for the CSWPolyCalc
    class.  The methods in this class should be used by an application
    to do polygon boolean operations.
*/


/*
    system header files
*/

#include <iostream>
#include <memory>
#include <math.h>
#include <string.h>
#include <ctype.h>

/*
    application header files
*/
#include "csw/utils/private_include/gpf_utils.h"
#include "csw/utils/private_include/ply_protoP.h"

#include "csw/utils/private_include/ply_utils.h"

#include "csw/utils/include/csw_errnum.h"
#include "csw/utils/include/csw_.h"
#include "csw/utils/private_include/ply_calc.h"
#include "csw/utils/private_include/ply_traverse.h"
#include "csw/utils/private_include/ply_gridvec.h"
#include "csw/utils/private_include/ply_drivers.h"
#include "csw/utils/private_include/ply_calc.h"
#include "csw/utils/private_include/ply_graph.h"

#include "csw/utils/private_include/csw_scope.h"


/*
******************************************************************

                 p l y _ C a l c I n t e r s e c t

******************************************************************

  function name:    ply_CalcIntersect (int)

  call sequence:    ply_CalcIntersect (err_obj,
                                       xs, ys, icomps, ncomps,
                                       xc, yc, icompc, ncompc,
                                       xout, yout, npout, icompout, iholeout,
                                       maxcomp, maxhole, maxpts)

  purpose:          Calculate the intersection of two sets of polygons.
                    The polygons may have multiply nested holes, but no
                    polygons may self intersect.

  return value:     status code

                    -1 = error calculating polygon intersection
                     1 = normal successful completion

  calling parameters:

    err_obj    w    CSWErrNum&  reference to CSWErrNum object which will report 
                               any error number generated by this function.
    xs         r    double*    array of x coordinates for source polygon set
    ys         r    double*    array of y coordinates for source polygon set
    icomps     r    int*       array with number of points per source component
    ncomps     r    int        number of source components
    xc         r    double*    array of x coordinates for clip polygon set
    yc         r    double*    array of y coordinates for clip polygon set
    icompc     r    int*       array with number of points per clip component
    ncompc     r    int        number of clip components
    xout       w    double*    array for x coordinates of output polygons
    yout       w    double*    array for y coordinates of output polygons
    npout      w    int*       number of separate polygons in output
    icompout   w    int*       array for number of components per output polygon
    iholeout   w    int*       array for number of points per component in
                               the set of output polygons
    maxcomp    r    int        maximum number of output components
    maxhole    r    int        maximum number of holes in the output
    maxpts     r    int        maximum number of output points

  errors:

    PLY_BADMALLOC    (1) = Error in allocating memory, probably because
                           the available memory is exhausted.
    PLY_WORKSIZE     (2) = The value for maxcomp, maxhole, or maxpts is
                           not large enough to support the array size
                           needed to complete the intersection calculation.
                           At a minimum, these parameters need to be as
                           large as the sum of the corresponding parameters
                           in both input polygon sets.
    PLY_IDENTPOLYS   (3) = Either two clip components are identical or two
                           source components are identical.  It is not an
                           error to have a clip component identical to a
                           source component.
    PLY_BADORIENT    (4) = The orientation of a polygon component cannot be
                           determined.  This can be because the component
                           has essentially zero area, or because the component
                           is self intersecting.


*/

int CSWPolyCalc::ply_CalcIntersect (CSWErrNum &err_obj,
                       double *xs, double *ys, int *icomps, int ncomps,
                       double *xc, double *yc, int *icompc, int ncompc,
                       double *xout, double *yout, int *npout, int *icompout,
                       int *iholeout, int maxcomp, int maxhole, int maxpts)
{
    int            i, j, k, l, m, mm, n, istat;
    double         cx1, cy1, cx2, cy2,
                   sx1, sy1, sx2, sy2, xt;

    double         *cxnestin = NULL, *cynestin = NULL,
                   *cxnestout = NULL, *cynestout = NULL,
                   *sxnestin = NULL, *synestin = NULL,
                   *sxnestout = NULL, *synestout = NULL,
                   *cxuse = NULL, *cyuse = NULL, *sxuse = NULL, *syuse = NULL,
                   *cxnow = NULL, *cynow = NULL, *sxnow = NULL, *synow = NULL;

    int            *choles = NULL, *ccomp2 = NULL, cnparts = 0,
                   *sholes = NULL, *scomp2 = NULL, snparts = 0;

    double         *dxout = NULL, *dyout = NULL,
                   *dxoutnow = NULL, *dyoutnow = NULL,
                   **xps = NULL, **yps = NULL, **xpc = NULL, **ypc = NULL,
                   *xmins = NULL, *ymins = NULL, *xmaxs = NULL, *ymaxs = NULL,
                   *xminc = NULL, *yminc = NULL, *xmaxc = NULL, *ymaxc = NULL;

    int            cptsoffset = 0, sptsoffset = 0, ncompnowc = 0, ncompnows = 0,
                   *ccompnowc = NULL, *ccompnows = NULL,
                   *icompoutnow = NULL, *iholeoutnow = NULL,
                   npolyoutnow = 0, ncomptotal = 0, nholetotal = 0, nptstotal = 0,
                   ntmp1 = 0, ntmp2 = 0;
    int            nptot;

    double         *extrax = NULL, *extray = NULL, *exout = NULL,
                   *eyout = NULL, *ex = NULL, *ey = NULL;
    int            nextra = 0, *extraholes = NULL, maxextra = 0, maxextraholes = 0,
                   *exhout = NULL, nexout = 0;

    CSWPolyUtils    ply_utils_obj;
    CSWPolyDrivers  ply_drivers_obj;

    auto fscope = [&]() 
    {
        csw_Free (extrax);
        csw_Free (extraholes);
        csw_Free (choles);
        csw_Free (xps);
        csw_Free (xmins);
        csw_Free (cxnestin);
    };
    CSWScopeGuard  func_scope_guard (fscope);

    if (maxcomp < 2) {
        err_obj.csw_SetErrNum (PLY_WORKSIZE);
        return -1;
    }

    if (maxhole < ncompc+ncomps) {
        err_obj.csw_SetErrNum (PLY_WORKSIZE);
        return -1;
    }

    nptot = 0;
    for (i=0; i<ncompc; i++) {
        nptot += icompc[i];
    }
    for (i=0; i<ncomps; i++) {
        nptot += icomps[i];
    }
    if (maxpts < nptot) {
        err_obj.csw_SetErrNum (PLY_WORKSIZE);
        return -1;
    }

    ply_utils_obj.ply_UtilMaxPts (maxpts);

/*  allocate memory for work arrays  */

    nextra = 0;
    maxextra = maxpts;
    maxextraholes = (maxcomp + maxhole) * 2;

    extrax = (double *)csw_Malloc (4 * maxextra * sizeof(double));
    if (!extrax) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    extray = extrax + maxpts;
    exout = extray + maxpts;
    eyout = extrax + maxpts;

    extraholes = (int *)csw_Malloc (2 * maxextraholes * sizeof(int));
    if (!extraholes) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    exhout = extraholes + maxextraholes;

    cxnestin = (double *)csw_Malloc (8 * maxpts * sizeof(double));
    if (!cxnestin) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    cynestin = cxnestin + maxpts;
    cxnestout = cynestin + maxpts;
    cynestout = cxnestout + maxpts;
    sxnestin = cynestout + maxpts;
    synestin = sxnestin + maxpts;
    sxnestout = synestin + maxpts;
    synestout = sxnestout + maxpts;

    choles = (int *)csw_Malloc (4 * maxhole * sizeof(int));
    if (!choles) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    ccomp2 = choles + maxhole;
    sholes = ccomp2 + maxhole;
    scomp2 = sholes + maxhole;

    dxout = xout;
    dyout = yout;

    xps = (double **)csw_Malloc (4 * maxhole * sizeof(double));
    if (!xps) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    yps = xps + maxhole;
    xpc = yps + maxhole;
    ypc = xpc + maxhole;

    xmins = (double *)csw_Malloc (8 * maxhole * sizeof(double));
    if (!xmins) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    ymins = xmins + maxhole;
    xmaxs = ymins + maxhole;
    ymaxs = xmaxs + maxhole;
    xminc = ymaxs + maxhole;
    yminc = xminc + maxhole;
    xmaxc = yminc + maxhole;
    ymaxc = xmaxc + maxhole;

/*
    copy to work arrays for calculation
*/
    n = 0;
    for (i=0; i<ncomps; i++) {
        for (j=0; j<icomps[i]; j++) {
            sxnestin[n] = (double)xs[n];
            synestin[n] = (double)ys[n];
            n++;
        }
    }

    n = 0;
    for (i=0; i<ncompc; i++) {
        for (j=0; j<icompc[i]; j++) {
            cxnestin[n] = (double)xc[n];
            cynestin[n] = (double)yc[n];
            n++;
        }
    }

/*
    set memory size parameters for hole nest function
*/
    xt = (double)maxpts;
    ply_utils_obj.ply_parms ('w', "maxpout", &xt);
    xt = (double)maxhole;
    ply_utils_obj.ply_parms ('w', "maxhout", &xt);

/*
    unnest clip polygon components
*/
    istat = ply_utils_obj.ply_holnest (cxnestin, cynestin, ncompc, icompc,
                         cxnestout, cynestout, &cnparts, ccomp2, choles);

    if (istat < 0) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    if (istat == 1) {
        err_obj.csw_SetErrNum (PLY_WORKSIZE);
        return -1;
    }
    if (istat == 3) {
        err_obj.csw_SetErrNum (PLY_IDENTPOLYS);
        return -1;
    }

    if (istat == 2) {
        cxuse = cxnestin;
        cyuse = cynestin;
        cnparts = 1;
        ccomp2[0] = ncompc;
        for (i=0; i<ncompc; i++) {
            choles[i] = icompc[i];
        }
    }
    else {
        cxuse = cxnestout;
        cyuse = cynestout;
    }

/*
    unnest source polygon components
*/
    istat = ply_utils_obj.ply_holnest (sxnestin, synestin, ncomps, icomps,
                         sxnestout, synestout, &snparts, scomp2, sholes);

    if (istat < 0) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    if (istat == 1) {
        err_obj.csw_SetErrNum (PLY_WORKSIZE);
        return -1;
    }
    if (istat == 3) {
        err_obj.csw_SetErrNum (PLY_IDENTPOLYS);
        return -1;
    }
    if (istat == 2) {
        sxuse = sxnestin;
        syuse = synestin;
        snparts = 1;
        scomp2[0] = ncomps;
        for (i=0; i<ncomps; i++) {
            sholes[i] = icomps[i];
        }
    }
    else {
        sxuse = sxnestout;
        syuse = synestout;
    }

/*
  -------------------------------------------------------------------

    for each part of the clip polygon set,
    calculate the intersection with each source part

  -------------------------------------------------------------------
*/
    icompoutnow = icompout;
    iholeoutnow = iholeout;
    ncomptotal = 0;
    nholetotal = 0;
    nptstotal = 0;
    dxoutnow = dxout;
    dyoutnow = dyout;

    ccompnowc = choles;
    ncompnowc = ccomp2[0];
    cxnow = cxuse;
    cynow = cyuse;

    for (i=0; i<cnparts; i++) {

/*        get limits and reorient each clip hole  */
        cx1 = 1.e30f;
        cy1 = 1.e30f;
        cx2 = -1.e30f;
        cy2 = -1.e30f;
        ply_utils_obj.ply_limits (cxnow, cynow, ccompnowc, ncompnowc,
                    xminc, yminc, xmaxc, ymaxc,
                    &cx1, &cy1, &cx2, &cy2);
        xpc[0] = cxnow;
        ypc[0] = cynow;
        cptsoffset = ccompnowc[0];
        for (k=1; k<ncompnowc; k++) {
            xpc[k] = xpc[k-1] + ccompnowc[k-1];
            ypc[k] = ypc[k-1] + ccompnowc[k-1];
            cptsoffset += ccompnowc[k];
        }

        istat = ply_utils_obj.ply_orient (1, xpc[0], ypc[0], ccompnowc[0],
                            xminc[0], yminc[0], xmaxc[0], ymaxc[0]);
        if (istat >= 1) {
            err_obj.csw_SetErrNum (PLY_BADORIENT);
            return -1;
        }
        for (k=1; k<ncompnowc; k++) {
            istat = ply_utils_obj.ply_orient (-1, xpc[k], ypc[k], ccompnowc[k],
                                xminc[k], yminc[k], xmaxc[k], ymaxc[k]);
            if (istat >= 1) {
                err_obj.csw_SetErrNum (PLY_BADORIENT);
                return -1;
            }
        }

        xt = cx2 - cx1 + cy2 - cy1;
        xt /= 5000.f;
        xt /= 5000.f;
        ply_utils_obj.ply_setgraze (xt);

/* --------------------------------------------------
        clip each source part to this clip part
   -------------------------------------------------- */

        sxnow = sxuse;
        synow = syuse;
        ccompnows = sholes;
        ncompnows = scomp2[0];

        for (j=0; j<snparts; j++) {

/*          get limits and orient each hole of the source polygon part  */

            sx1 = 1.e30f;
            sy1 = 1.e30f;
            sx2 = -1.e30f;
            sy2 = -1.e30f;
            ply_utils_obj.ply_limits (sxnow, synow, ccompnows, ncompnows,
                        xmins, ymins, xmaxs, ymaxs,
                        &sx1, &sy1, &sx2, &sy2);
            xps[0] = sxnow;
            yps[0] = synow;
            sptsoffset = ccompnows[0];
            for (k=1; k<ncompnows; k++) {
                xps[k] = xps[k-1] + ccompnows[k-1];
                yps[k] = yps[k-1] + ccompnows[k-1];
                sptsoffset += ccompnows[k];
            }

            istat = ply_utils_obj.ply_orient (1, xps[0], yps[0], ccompnows[0],
                                xmins[0], ymins[0], xmaxs[0], ymaxs[0]);
            if (istat >= 1) {
                err_obj.csw_SetErrNum (PLY_BADORIENT);
                return -1;
            }
            for (k=1; k<ncompnows; k++) {
                istat = ply_utils_obj.ply_orient (-1, xps[k], yps[k], ccompnows[k],
                                    xmins[k], ymins[k], xmaxs[k], ymaxs[k]);
                if (istat >= 1) {
                    err_obj.csw_SetErrNum (PLY_BADORIENT);
                    return -1;
                }
            }

/*
            Calculate the intersecting components of the current clip
            and source polygons.  The output is appended to the previously
            calculated components.
*/

            ply_gridvec_obj.ply_setupvecgrids (cxnow, cynow, ncompnowc, ccompnowc,
                               sxnow, synow, ncompnows, ccompnows);

            xt = (double)(maxpts - nptstotal);
            ply_utils_obj.ply_parms ('w', "maxpout", &xt);
            xt = (double)(maxhole - nholetotal);
            ply_utils_obj.ply_parms ('w', "maxhout", &xt);

            nextra = 0;
            istat = ply_drivers_obj.ply_intcomps (err_obj,
                                  ply_gridvec_obj,
                                  sxnow, synow, ncompnows, ccompnows,
                                  xps, yps, xmins, ymins, xmaxs, ymaxs,
                                  cxnow, cynow, ncompnowc, ccompnowc,
                                  xpc, ypc, xminc, yminc, xmaxc, ymaxc,
                                  dxoutnow, dyoutnow, &npolyoutnow,
                                  icompoutnow, iholeoutnow,
                                  extrax, extray,
                                  &nextra, extraholes, maxextra, maxextraholes);

            if (istat == -1) {
                err_obj.csw_SetErrNum (PLY_BADMALLOC);
                return -1;
            }
            if (istat == 1) {
                err_obj.csw_SetErrNum (PLY_WORKSIZE);
                return -1;
            }

/*          if no intersection found, try reversing clip and source  */

            if (istat == 2) {
                ply_gridvec_obj.ply_SetSrcClipGrids (-1);
                nextra = 0;
                istat = ply_drivers_obj.ply_intcomps (err_obj,
                                      ply_gridvec_obj,
                                      cxnow, cynow, ncompnowc, ccompnowc,
                                      xpc, ypc, xminc, yminc, xmaxc, ymaxc,
                                      sxnow, synow, ncompnows, ccompnows,
                                      xps, yps, xmins, ymins, xmaxs, ymaxs,
                                      dxoutnow, dyoutnow, &npolyoutnow,
                                      icompoutnow, iholeoutnow,
                                      extrax, extray,
                                      &nextra, extraholes, maxextra, maxextraholes);
                ply_gridvec_obj.ply_SetSrcClipGrids (1);
                if (istat == 2) {
                    npolyoutnow = 0;
                }
            }

            nexout = 0;
            if (nextra > 0) {
                ProcessExtra
                       (err_obj,
                        dxoutnow, dyoutnow, npolyoutnow, icompoutnow, iholeoutnow,
                        extrax, extray, nextra, extraholes, maxextra, maxextraholes,
                        exout, eyout, exhout, &nexout);
            }

        /*
            Increment the input and output pointers for the next
            clip/source polygon pair in the set.
        */
            ncomptotal += npolyoutnow;
            mm = 0;
            ntmp1 = 0;
            ntmp2 = 0;
            for (k=0; k<npolyoutnow; k++) {
                m = icompoutnow[k];
                ntmp1 += m;
                for (l=0; l<m; l++) {
                    ntmp2 += iholeoutnow[mm];
                    mm++;
                }
            }
            if (ntmp2 > 9) {
                ntmp2 = ntmp2;
            }

            nholetotal += ntmp1;
            nptstotal += ntmp2;

            dxoutnow += ntmp2;
            dyoutnow += ntmp2;
            icompoutnow += npolyoutnow;
            iholeoutnow += ntmp1;

        /*
            append the extra polygons gotten from hole intersection if there are any.
        */
            ex = exout;
            ey = eyout;
            for (k=0; k<nexout; k++) {
                m = exhout[k];
                ply_utils_obj.ply_copy (ex, ey, m, dxoutnow, dyoutnow);
                *icompoutnow = 1;
                *iholeoutnow = m;
                icompoutnow++;
                iholeoutnow++;
                ncomptotal++;
                dxoutnow += m;
                dyoutnow += m;
                ex += m;
                ey += m;
            }

        /*
            increment source coordinates pointers
        */
            sxnow += sptsoffset;
            synow += sptsoffset;
            ccompnows += ncompnows;
            if (j < snparts - 1) {
                ncompnows = scomp2[j+1];
            }

        }  /*  end of loop through source polygons for a clip polygon  */

/*
        Increment pointers to the clip polygon data to
        define the next polygon in the clip polygon set
*/

        cxnow += cptsoffset;
        cynow += cptsoffset;
        ccompnowc += ncompnowc;
        if (i < cnparts - 1) {
            ncompnowc = ccomp2[i+1];
        }

    }  /*  end of loop through clip polygons in the set  */

    *npout = ncomptotal;

    return 1;

}  /*  end of function ply_CalcIntersect  */






/*
******************************************************************

                      p l y _ C a l c X o r

******************************************************************

  function name:    ply_CalcXor (int)

  call sequence:    ply_CalcXor (err_obj,
                                 xs, ys, icomps, ncomps,
                                 xc, yc, icompc, ncompc,
                                 xout, yout, npout, icompout, iholeout,
                                 maxcomp, maxhole, maxpts)

  purpose:          Calculate the areas that are in only one of two sets
                    of polygons.
                    The polygons may have multiply nested holes, but no
                    polygons may self intersect.

  return value:     status code

                    -1 = error calculating polygon intersection
                     1 = normal successful completion

  calling parameters:

    err_obj    w    CSWErrNum&  Reference to error number return object.
    xs         r    double*    array of x coordinates for source polygon set
    ys         r    double*    array of y coordinates for source polygon set
    icomps     r    int*       array with number of points per source component
    ncomps     r    int        number of source components
    xc         r    double*    array of x coordinates for clip polygon set
    yc         r    double*    array of y coordinates for clip polygon set
    icompc     r    int*       array with number of points per clip component
    ncompc     r    int        number of clip components
    xout       w    double*    array for x coordinates of output polygons
    yout       w    double*    array for y coordinates of output polygons
    npout      w    int*       number of separate polygons in output
    icompout   w    int*       array for number of components per output polygon
    iholeout   w    int*       array for number of points per component in
                               the set of output polygons
    maxcomp    r    int        maximum number of output components
    maxhole    r    int        maximum number of holes in the output
    maxpts     r    int        maximum number of output holes

  errors:

    PLY_BADMALLOC    (1) = Error in allocating memory, probably because
                           the available memory is exhausted.
    PLY_WORKSIZE     (2) = The value for maxcomp, maxhole, or maxpts is
                           not large enough to support the array size
                           needed to complete the intersection calculation.
    PLY_IDENTPOLYS   (3) = Either two clip components are identical or two
                           source components are identical.  It is not an
                           error to have a clip component identical to a
                           source component.
    PLY_BADORIENT    (4) = The orientation of a polygon component cannot be
                           determined.  This can be because the component
                           has essentially zero area, or because the component
                           is self intersecting.


*/

int CSWPolyCalc::ply_CalcXor (CSWErrNum &err_obj,
                 double *xs, double *ys, int *icomps, int ncomps,
                 double *xc, double *yc, int *icompc, int ncompc,
                 double *xout, double *yout,
                 int *npout, int *icompout, int *iholeout,
                 int maxcomp, int maxhole, int maxpts)
{
    int            i, j, k, n, istat, nploc, npsav, ntmp1, ntmp2;
    double         *xwork, *ywork, x1, y1, x2, y2, w1;
    int            *iwork;

    auto fscope = [&]() 
    {
        csw_Free (iwork);
        csw_Free (xwork);
    };
    CSWScopeGuard  func_scope_guard (fscope);

/*  allocate memory for work arrays  */

    iwork = (int *)csw_Malloc (maxhole * sizeof(int));
    if (!iwork) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }

    xwork = (double *)csw_Malloc (maxpts * 2 * sizeof(double));
    if (!xwork) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }
    ywork = xwork + maxpts;

/*  find limits of all input polygons  */

    x1 = 1.e30f;
    y1 = 1.e30f;
    x2 = -1.e30f;
    y2 = -1.e30f;

    k = 0;
    for (i=0; i<ncomps; i++) {
        n = icomps[i];
        for (j=0; j<n; j++) {
            if (xs[k] < x1) x1 = xs[k];
            if (ys[k] < y1) y1 = ys[k];
            if (xs[k] > x2) x2 = xs[k];
            if (ys[k] > y2) y2 = ys[k];
            k++;
        }
    }

    k = 0;
    for (i=0; i<ncompc; i++) {
        n = icompc[i];
        for (j=0; j<n; j++) {
            if (xc[k] < x1) x1 = xc[k];
            if (yc[k] < y1) y1 = yc[k];
            if (xc[k] > x2) x2 = xc[k];
            if (yc[k] > y2) y2 = yc[k];
            k++;
        }
    }

/*
    create rectangle outside of bounds to use as a "parent"
    for the source and clip polygon sets
*/

    w1 = (x2 - x1 + y2 - y1) / 4.f;
    x1 -= w1;
    x2 += w1;
    y1 -= w1;
    y2 += w1;

/*  reparent source polygon set with the rectangle  */

    ReparentPolySet (xs, ys, icomps, ncomps,
                     x1, y1, x2, y2,
                     xwork, ywork, iwork);

/*
    calculate intersections using reparented source as source
    and input clip as clip
*/

    istat = ply_CalcIntersect (err_obj,
                               xc, yc, icompc, ncompc,
                               xwork, ywork, iwork, ncomps+1,
                               xout, yout, &nploc, icompout, iholeout,
                               maxcomp, maxhole, maxpts);
    if (istat < 0) {
        return -1;
    }

/*  reset output pointers based on the first intersection results  */

    npsav = nploc;
    ntmp1 = 0;
    ntmp2 = 0;
    k = 0;
    for (i=0; i<nploc; i++) {
        n = icompout[i];
        ntmp1 += n;
        for (j=0; j<n; j++) {
            ntmp2 += iholeout[k];
            k++;
        }
    }

    xout += ntmp2;
    yout += ntmp2;
    icompout += nploc;
    iholeout += ntmp1;
    maxcomp -= nploc;
    maxhole -= ntmp1;
    maxpts -= ntmp2;

/*  reparent the clip polygon set with the outline rectangle  */

    ReparentPolySet (xc, yc, icompc, ncompc,
                     x1, y1, x2, y2,
                     xwork, ywork, iwork);

/*  calculate intersection using reparented clip as source  */

    istat = ply_CalcIntersect (err_obj,
                               xs, ys, icomps, ncomps,
                               xwork, ywork, iwork, ncompc+1,
                               xout, yout, &nploc, icompout, iholeout,
                               maxcomp, maxhole, maxpts);

    *npout = nploc + npsav;


    return istat;

}  /*  end of function ply_CalcXor  */



/*
******************************************************************

                   R e p a r e n t P o l y S e t

******************************************************************

    Set a rectangle as the first component of a polygon set and
    append the rest of the set after the rectangle.  This is only
    called from ply_CalcXor.

*/

int CSWPolyCalc::ReparentPolySet (double *x, double *y, int *icomp, int ncomp,
                            double x1, double y1, double x2, double y2,
                            double *xout, double *yout, int *iout)
{
    int            i, j, k, n, nt, kk;

    xout[0] = x1;
    yout[0] = y1;
    xout[1] = x1;
    yout[1] = y2;
    xout[2] = x2;
    yout[2] = y2;
    xout[3] = x2;
    yout[3] = y1;
    xout[4] = x1;
    yout[4] = y1;

    iout[0] = 5;

    kk = 5;
    k = 0;
    n = 1;

    for (i=0; i<ncomp; i++) {
        nt = icomp[i];
        iout[n] = nt;
        for (j=0; j<nt; j++) {
            xout[kk] = x[k];
            yout[kk] = y[k];
            kk++;
            k++;
        }
        n++;
    }

    return 1;

}  /*  end of private function ReparentPolySet  */




/*
******************************************************************

                      p l y _ C a l c X o r 1

******************************************************************

  function name:    ply_CalcXor1 (int)

  call sequence:    ply_CalcXor1 (err_obj,
                                  xs, ys, icomps, ncomps,
                                  xc, yc, icompc, ncompc,
                                  xout, yout, npout, icompout, iholeout,
                                  maxcomp, maxhole, maxpts)

  purpose:          Calculate the areas that are in only one of two sets
                    of polygons.
                    The polygons may have multiply nested holes, but no
                    polygons may self intersect.  All polygon vertices
                    are passed as CSW_Fs.

  return value:     status code

                    -1 = error calculating polygon intersection
                     1 = normal successful completion

  calling parameters:

    err_obj    w    CSWErrNum&  Reference to error number return object.
    xs         r    CSW_F*     array of x coordinates for source polygon set
    ys         r    CSW_F*     array of y coordinates for source polygon set
    icomps     r    int*       array with number of points per source component
    ncomps     r    int        number of source components
    xc         r    CSW_F*     array of x coordinates for clip polygon set
    yc         r    CSW_F*     array of y coordinates for clip polygon set
    icompc     r    int*       array with number of points per clip component
    ncompc     r    int        number of clip components
    xout       w    CSW_F*     array for x coordinates of output polygons
    yout       w    CSW_F*     array for y coordinates of output polygons
    npout      w    int*       number of separate polygons in output
    icompout   w    int*       array for number of components per output polygon
    iholeout   w    int*       array for number of points per component in
                               the set of output polygons
    maxcomp    r    int        maximum number of output components
    maxhole    r    int        maximum number of holes in the output
    maxpts     r    int        maximum number of output holes

  errors:

    PLY_BADMALLOC    (1) = Error in allocating memory, probably because
                           the available memory is exhausted.
    PLY_WORKSIZE     (2) = The value for maxcomp, maxhole, or maxpts is
                           not large enough to support the array size
                           needed to complete the intersection calculation.
    PLY_IDENTPOLYS   (3) = Either two clip components are identical or two
                           source components are identical.  It is not an
                           error to have a clip component identical to a
                           source component.
    PLY_BADORIENT    (4) = The orientation of a polygon component cannot be
                           determined.  This can be because the component
                           has essentially zero area, or because the component
                           is self intersecting.


*/

int CSWPolyCalc::ply_CalcXor1 (CSWErrNum &err_obj,
                  CSW_F *xs, CSW_F *ys, int *icomps, int ncomps,
                  CSW_F *xc, CSW_F *yc, int *icompc, int ncompc,
                  CSW_F *xout, CSW_F *yout,
                  int *npout, int *icompout, int *iholeout,
                  int maxcomp, int maxhole, int maxpts)
{
    double         *dx1 = NULL, *dy1 = NULL, *dx2 = NULL,
                   *dy2 = NULL, *dx3 = NULL, *dy3 = NULL;
    int            istat, i, j, n, n1, n2, n3;

    auto fscope = [&]() 
    {
        csw_Free (dx1);
    };
    CSWScopeGuard  func_scope_guard (fscope);

/*  allocate space for double coordinate arrays  */

    dx1 = (double *)csw_Malloc (6 * maxpts * sizeof(double));
    if (!dx1) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }

    dy1 = dx1 + maxpts;
    dx2 = dy1 + maxpts;
    dy2 = dx2 + maxpts;
    dx3 = dy2 + maxpts;
    dy3 = dx3 + maxpts;

/*  transfer input coordinates to double arrays  */

    n = 0;
    for (i=0; i<ncomps; i++) {
        n += icomps[i];
    }
    for (i=0; i<n; i++) {
        dx1[i] = xs[i];
        dy1[i] = ys[i];
    }

    n = 0;
    for (i=0; i<ncompc; i++) {
        n += icompc[i];
    }
    for (i=0; i<n; i++) {
        dx2[i] = xc[i];
        dy2[i] = yc[i];
    }

/*  call the double version of the function  */

    istat = ply_CalcXor (err_obj,
                         dx1, dy1, icomps, ncomps,
                         dx2, dy2, icompc, ncompc,
                         dx3, dy3, &n2, icompout, iholeout,
                         maxcomp, maxhole, maxpts);
    if (istat < 0) {
        return -1;
    }

/*  convert double results back to CSW_F  */

    n3 = 0;
    n = 0;
    for (i=0; i<n2; i++) {
        n1 = icompout[i];
        for (j=0; j<n1; j++) {
            n += iholeout[n3];
            n3++;
        }
    }

    for (i=0; i<n; i++) {
        xout[i] = (CSW_F)dx3[i];
        yout[i] = (CSW_F)dy3[i];
    }

    *npout = n2;

    return 1;

}  /*  end of function ply_CalcXor1  */



#if 0
/*
******************************************************************

               p l y _ C a l c I n t e r s e c t 1

******************************************************************

  function name:    ply_CalcIntersect1 (int)

  call sequence:    ply_CalcIntersect1 (err_obj,
                                        xs, ys, icomps, ncomps,
                                        xc, yc, icompc, ncompc,
                                        xout, yout, npout, icompout, iholeout,
                                        maxcomp, maxhole, maxpts)

  purpose:          Calculate the intersection of two sets of polygons.
                    The polygons may have multiply nested holes, but no
                    polygons may self intersect.  All polygon vertices
                    are passed as CSW_Fs.

  return value:     status code

                    -1 = error calculating polygon intersection
                     1 = normal successful completion

  calling parameters:

    err_obj    w    CSWErrNum&   Reference to object that can return an error
                               number.
    xs         r    CSW_F*     array of x coordinates for source polygon set
    ys         r    CSW_F*     array of y coordinates for source polygon set
    icomps     r    int*       array with number of points per source component
    ncomps     r    int        number of source components
    xc         r    CSW_F*     array of x coordinates for clip polygon set
    yc         r    CSW_F*     array of y coordinates for clip polygon set
    icompc     r    int*       array with number of points per clip component
    ncompc     r    int        number of clip components
    xout       w    CSW_F*     array for x coordinates of output polygons
    yout       w    CSW_F*     array for y coordinates of output polygons
    npout      w    int*       number of separate polygons in output
    icompout   w    int*       array for number of components per output polygon
    iholeout   w    int*       array for number of points per component in
                               the set of output polygons
    maxcomp    r    int        maximum number of output components
    maxhole    r    int        maximum number of holes in the output
    maxpts     r    int        maximum number of output holes

  errors:

    PLY_BADMALLOC    (1) = Error in allocating memory, probably because
                           the available memory is exhausted.
    PLY_WORKSIZE     (2) = The value for maxcomp, maxhole, or maxpts is
                           not large enough to support the array size
                           needed to complete the intersection calculation.
    PLY_IDENTPOLYS   (3) = Either two clip components are identical or two
                           source components are identical.  It is not an
                           error to have a clip component identical to a
                           source component.
    PLY_BADORIENT    (4) = The orientation of a polygon component cannot be
                           determined.  This can be because the component
                           has essentially zero area, or because the component
                           is self intersecting.


*/

int CSWPolyCalc::ply_CalcIntersect1 (CSWErrNum &err_obj,
                        CSW_F *xs, CSW_F *ys, int *icomps, int ncomps,
                        CSW_F *xc, CSW_F *yc, int *icompc, int ncompc,
                        CSW_F *xout, CSW_F *yout,
                        int *npout, int *icompout, int *iholeout,
                        int maxcomp, int maxhole, int maxpts)
{
    double         *dx1 = NULL, *dy1 = NULL, *dx2 = NULL,
                   *dy2 = NULL, *dx3 = NULL, *dy3 = NULL;
    int            istat, i, j, n, n1, n2, n3;

    auto fscope = [&]() 
    {
        csw_Free (dx1);
    };
    CSWScopeGuard  func_scope_guard (fscope);

    std::unique_ptr <CSWPolyGraph>
        ply_graph_obj {new CSWPolyGraph ()};

    maxcomp = maxcomp;

/*  allocate space for double coordinate arrays  */

    dx1 = (double *)csw_Malloc (6 * maxpts * sizeof(double));
    if (!dx1) {
        err_obj.csw_SetErrNum (PLY_BADMALLOC);
        return -1;
    }

    dy1 = dx1 + maxpts;
    dx2 = dy1 + maxpts;
    dy2 = dx2 + maxpts;
    dx3 = dy2 + maxpts;
    dy3 = dx3 + maxpts;

/*  transfer input coordinates to double arrays  */

    n = 0;
    for (i=0; i<ncomps; i++) {
        n += icomps[i];
    }
    for (i=0; i<n; i++) {
        dx1[i] = xs[i];
        dy1[i] = ys[i];
    }

    n = 0;
    for (i=0; i<ncompc; i++) {
        n += icompc[i];
    }
    for (i=0; i<n; i++) {
        dx2[i] = xc[i];
        dy2[i] = yc[i];
    }

/*  call the double version of the function  */

    istat = ply_graph_obj->ply_boolean
                        (dx1, dy1, NULL, 1, &ncomps, icomps,
                         dx2, dy2, NULL, 1, &ncompc, icompc,
                         PLY_INTERSECT,
                         dx3, dy3, NULL, &n2, icompout, iholeout,
                         maxpts, maxhole);
    if (istat < 0) {
        return -1;
    }

/*  convert double results back to CSW_F  */

    n3 = 0;
    n = 0;
    for (i=0; i<n2; i++) {
        n1 = icompout[i];
        for (j=0; j<n1; j++) {
            n += iholeout[n3];
            n3++;
        }
    }

    for (i=0; i<n; i++) {
        xout[i] = (CSW_F)dx3[i];
        yout[i] = (CSW_F)dy3[i];
    }

    *npout = n2;

    return 1;

}  /*  end of function ply_CalcIntersect1  */
#endif



/*
  ****************************************************************

            p l y _ C l i p P l i n e T o A r e a

  ****************************************************************

  function name:     ply_ClipPlineToArea         (int)

  call sequence:     ply_ClipPlineToArea (flag, xp, yp, ic, ncin,
                                          xvc, yvc, ivc, nvc,
                                          xline, yline, nline,
                                          xout, yout, iout, nout,
                                          maxpts, maxcomps)

  purpose:           Clip a polyline to either the inside or the
                     outside of a complex polygon.

  return value:      status code

                     -1 = memory allocation error
                      1 = normal successful completion

  calling parameters:

    flag         r     int      -1 = return the parts outside the polygon
                                 1 = return the parts inside the polygon
    xp           r     double*   x polygon vertices
    yp           r     double*   y polygon vertices
    ic           r     int*      number of points per component
    ncin         r     int       number of components
    xvc          r     double*   x coordinates of clip vectors
    yvc          r     double*   y coordinates of clip vectors
    ivc          r     int*      number of vectors per clip component
    nvc          r     int       number of clip components
                    note:
                          The clip vectors may be all of the polyline vectors
                          or a subset of the polyline vectors that excludes
                          polyline sides that are outside of the polygon to
                          be clipped to.  The polygon points must be the complete
                          polygon, since they are used to determine whether
                          a clipped result is inside or outside of the polygon.

    xline        r     double*   x line coordinates
    yline        r     double*   y line coordinates
    nline        r     int       number of points in line
    xout         w     double*   array for output x coordinates
    yout         w     double*   array for output y coordinates
    iout         w     int*      array for points per output component
    nout         w     int*      number of output components
    maxpts       r     int       maximum size of xout and yout arrays
    maxcomps     r     int       maximum size of iout array

*/

int CSWPolyCalc::ply_ClipPlineToArea (
               int flag, double *xp, double *yp, int *ic, int ncin,
               double *xvc, double *yvc, int *ivc, int nvc,
               double *xline, double *yline, int nline,
               double *xout, double *yout, int *iout, int *nout,
               int maxpts, int maxcomps)
{
    double       **xpw, **ypw, **xpvw, **ypvw;
    int          nt=0, n, i, istat, jstat, n2=0, k, nwmax;
    double       xx1, yy1, xx2, yy2, xint, yint, grsave, grt,
                 *xw, *yw, xpt, *xpnest, *ypnest;
    int          nc, npn, ncn, npnest, *ipnest, *jpnest;
    double       *tpx, *tpy;
    int          ntpc, *itpc, *jtpc;

    CSWPolyUtils  ply_utils_obj;
    CSWPolyTraverse  ply_traverse_obj;


    auto fscope = [&]() 
    {
        csw_Free (xpw);
        csw_Free (xpnest);
        csw_Free (ipnest);
        csw_Free (xpvw);
        csw_Free (xw);
    };
    CSWScopeGuard  func_scope_guard (fscope);

/*
 * Initialize output in case of an error.
 */
    *nout = 0;
    iout[0] = 0;
    nc = ncin;

    if (maxpts < 2  ||  maxcomps < 1) {
        return -1;
    }

    if (xline == NULL  ||  yline == NULL  ||  nline < 2) {
        return -1;
    }

/*
    allocate work space memory
*/
    xpw = (double **)csw_Malloc (nc * 2 * sizeof (double *));
    if (!xpw) {
        return -1;
    }
    ypw = xpw + nc;

    n = 0;
    for (i=0; i<nc; i++) {
        xpw[i] = xp + n;
        ypw[i] = yp + n;
        n += ic[i];
    }

    ncn = nc + 2;
    npn = n + 10;

    xpnest = (double *)csw_Malloc (npn * 2 * sizeof (double));
    if (!xpnest) {
        return -1;
    }
    ypnest = xpnest + npn;

    ipnest = (int *)csw_Malloc (ncn * 2 * sizeof(int));
    if (!ipnest) {
        return -1;
    }
    jpnest = ipnest + ncn;

    xpvw = (double **)csw_Malloc (nvc * 2 * sizeof (double *));
    if (!xpvw) {
        return -1;
    }
    ypvw = xpvw + nvc;

    n = 0;
    for (i=0; i<nvc; i++) {
        xpvw[i] = xvc + n;
        ypvw[i] = yvc + n;
        n += ivc[i];
    }

    nwmax = maxpts;
    xw = (double *)csw_Malloc (2 * nwmax * sizeof(double));
    if (!xw) {
        return -1;
    }
    yw = xw + nwmax;

/*
    unnest the polygon holes
*/
    xpt = (double)npn;
    ply_utils_obj.ply_parms ('w', "maxpout", &xpt);
    xpt = (double)ncn;
    ply_utils_obj.ply_parms ('w', "maxhout", &xpt);

    istat = ply_utils_obj.ply_holnest (xp, yp, nc, ic,
                         xpnest, ypnest, &npnest, ipnest, jpnest);

    if (istat == 0) {
        tpx = xpnest;
        tpy = ypnest;
        ntpc = npnest;
        itpc = ipnest;
        jtpc = jpnest;
    }
    else if (istat == 2) {
        tpx = xp;
        tpy = yp;
        ntpc = 1;
        itpc = &nc;
        jtpc = ic;
    }
    else {
        return -1;
    }

/*
    Loop through the line vectors and calculate polyline segments
    between intersections with the polygon.  Save the appropriate
    segments depending on the flag value.
*/
    ply_utils_obj.ply_getgraze (&grsave);
    ply_utils_obj.ply_setgraze ((double)0.0f);

    xx1 = xline[0];
    yy1 = yline[0];
    i = 1;
    n = 1;
    nt = 0;
    n2 = 0;
    xw[0] = xx1;
    yw[0] = yy1;

    while (i < nline) {
      xx2 = xline[i];
      yy2 = yline[i];
      if (xx1 - xx2 == 0.0  &&  yy1 - yy2 == 0.0) {
        i++;
        continue;
      }
      istat = ply_traverse_obj.ply_ClipVecToArea (xpvw, ypvw, nvc, ivc,
                                 xx1, yy1, xx2, yy2,
                                 &xint, &yint);

      /*      intersection found  */

      if (istat == 0  ||  istat == 3) {
        xw[n] = xint;
        yw[n] = yint;
        n++;
        jstat = ply_utils_obj.ply_PlineInOut (tpx, tpy, ntpc, itpc, jtpc,
                                  xw, yw, n);

        /*          the segment is on the correct "side" of the polygon  */

        if (jstat == flag) {
          for (k=0; k<n; k++) {
            xout[n2] = xw[k];
            yout[n2] = yw[k];
            n2++;
            if (n2 >= maxpts) {
              *nout = 0;
              iout[0] = 0;
              ply_utils_obj.ply_setgraze (grsave);
              return -1;
            }
          }
          iout[nt] = n;
          nt++;
          if (nt >= maxcomps) {
            *nout = 0;
            iout[0] = 0;
            ply_utils_obj.ply_setgraze (grsave);
            return -1;
          }
        }

        xx1 = xint;
        yy1 = yint;
        n = 1;
        xw[0] = xx1;
        yw[0] = yy1;
        ply_utils_obj.ply_getgraze (&grt);
        ply_utils_obj.ply_setgraze (grt * 1.2f);
        if (ply_utils_obj.ply_graze (xint, yint, xx2, yy2)) {
          istat = 3;
        }
        if (istat == 3) {
          i++;
        }
      }

      /*      no intersection or intersection at xx1, yy1  */

      else {
        xx1 = xx2;
        yy1 = yy2;
        xw[n] = xx1;
        yw[n] = yy1;
        n++;
        i++;
      }
    }

/*  output last segment if needed  */

    jstat = ply_utils_obj.ply_PlineInOut (tpx, tpy, ntpc, itpc, jtpc,
                            xw, yw, n);

    if (jstat == flag) {
        for (k=0; k<n; k++) {
            xout[n2] = xw[k];
            yout[n2] = yw[k];
            n2++;
            if (n2 >= maxpts) {
                *nout = 0;
                iout[0] = 0;
                ply_utils_obj.ply_setgraze (grsave);
                return -1;
            }
        }
        iout[nt] = n;
        nt++;
        if (*nout >= maxcomps) {
            *nout = 0;
            iout[0] = 0;
            ply_utils_obj.ply_setgraze (grsave);
            return -1;
        }
    }

    *nout = nt;
    ply_utils_obj.ply_setgraze (grsave);

    return 1;

}  /*  end of function ply_ClipPlineToArea  */





/*
    ***************************************************************

                   p l y _ C l i p T o B o x 1

    ***************************************************************

    function name:     ply_ClipToBox1       (int)

    calling syntax:    ply_ClipToBox1 (err_obj,
                                       xs, ys, icomps, ncomps,
                                       x1, y1, x2, y2,
                                       xout, yout, icompout, ncompout,
                                       maxcomp, maxpts)

    synopsis:          Clip a polygon to a rectangular area.  Returns
                       the part of the polygon inside the box.

    return status:     status code

                       1 = normal successful completion.
                       0 = polygon is entirely outside of the box.
                      -1 = error clipping polygon, probably memory
                           allocation failure.

    parameters:

    err_obj   w    CSWErrNum&    Reference to object that may
                                return an error number.
    xs        r    CSW_F*       array of polygon x coordinates
    ys        r    CSW_F*       array of polygon y coordinates
    icomps    r    int*         number of points per polygon component
    ncomps    r    int          number of polygon components
    x1        r    CSW_F        minimum x of box
    y1        r    CSW_F        minimum y of box
    x2        r    CSW_F        maximum x of box
    y2        r    CSW_F        maximum y of box
    xout      w    CSW_F*       array for output x coordinates
    yout      w    CSW_F*       array for output y coordinates
    icompout  w    int*         array with number of points per
                                output component
    ncompout  w    int*         number of output components
    maxcomp   r    int          maximum number of output components
    maxpts    r    int          maximum number of output points

*/

int CSWPolyCalc::ply_ClipToBox1 (CSWErrNum &err_obj,
                    CSW_F *xs, CSW_F *ys, int *icomps, int ncomps,
                    CSW_F x1_in, CSW_F y1_in, CSW_F x2_in, CSW_F y2_in,
                    CSW_F *xout, CSW_F *yout, int *icompout, int *ncompout,
                    int maxcomp, int maxpts)
{
    CSW_F       x1, y1, x2, y2;
    int         i, j, n, istat, icompc, ncompc;
    CSW_F       x11, y11, x22, y22, xc[5], yc[5];
    int         *ncout = NULL, *nhout = NULL, npout;


    auto fscope = [&]() 
    {
        csw_Free (ncout);
    };
    CSWScopeGuard  func_scope_guard (fscope);


    if (x1_in < x2_in) {
        x1 = x1_in;
        x2 = x2_in;
    }
    else {
        x1 = x2_in;
        x2 = x1_in;
    }
    if (y1_in < y2_in) {
        y1 = y1_in;
        y2 = y2_in;
    }
    else {
        y1 = y2_in;
        y2 = y1_in;
    }

/*
    check if the polygon needs to be clipped
*/
    n = 0;
    for (i=0; i<ncomps; i++) {
        n += icomps[i];
    }

    gpf_xandylimits (xs, ys, n,
                     &x11, &y11, &x22, &y22);

/*
    if completely inside box, copy input to
    output and return success
*/
    if (x11 >= x1  &&  x22 <= x2  &&  y11 >= y1  &&  y22 <= y2) {

        n = 0;
        for (i=0; i<ncomps; i++) {
            icompout[i] = icomps[i];
            n += icomps[i];
        }
        for (i=0; i<n; i++) {
            xout[i] = xs[i];
            yout[i] = ys[i];
        }
        *ncompout = ncomps;
        return 1;

    }

/*
    polygon is completely outside of the box
*/
    if (x11 > x2  ||  x22 < x1  ||  y11 > y2  ||  y22 < y1) {
        return 0;
    }

/*
    allocate integer work space
*/
    ncout = (int *)csw_Malloc (2 * maxcomp * sizeof(int));
    if (!ncout) {
        return -1;
    }
    nhout = ncout + maxcomp;

/*
    fill in array for clip rectangle
*/
    xc[0] = x1;
    yc[0] = y1;
    xc[1] = x1;
    yc[1] = y2;
    xc[2] = x2;
    yc[2] = y2;
    xc[3] = x2;
    yc[3] = y1;
    xc[4] = x1;
    yc[4] = y1;
    icompc = 5;
    ncompc = 1;

/*
    calculate intersection of box and polygon
*/
    istat = ply_CalcIntersect  (err_obj,
                                xs, ys, icomps, ncomps,
                                xc, yc, &icompc, ncompc,
                                xout, yout, &npout, ncout, nhout,
                                maxcomp, maxcomp, maxpts);
    if (istat == -1) {
        return -1;
    }

    if (npout < 1) {
        return 0;
    }

/*
    compress multiple components into holes of
    a single component
*/
    n = 0;
    for (i=0; i<npout; i++) {
        for (j=0; j<ncout[i]; j++) {
            icompout[n] = nhout[n];
            n++;
        }
    }

    *ncompout = n;

    return 1;

}  /*  end of function ply_ClipToBox1  */






/*
  ****************************************************************

                      P r o c e s s E x t r a

  ****************************************************************

    Any extra polygons gotten from the hole union in the intersection
  algorithm need to be clipped against the previous clip results.
  The results from this are separate polygons that are part of the
  complete intersection of the original polygons.  They are actually
  second level holes but they can be treated as separate polygons.

    This function is only called from the ply_CalcIntersect function.
  Don't use it for anything else.

*/

int CSWPolyCalc::ProcessExtra (CSWErrNum &err_obj,
     double *xc, double *yc, int nc, int *icompc, int *iholec,
     double *xs, double *ys, int ns, int *sholes, int max1, int max2,
     double *xout, double *yout, int *hout, int *cout)
{

    double         **xpc = NULL, **ypc = NULL, **xps = NULL, **yps = NULL,
                   *xminc = NULL, *yminc = NULL, *xmaxc = NULL, *ymaxc = NULL,
                   *xmins = NULL, *ymins = NULL, *xmaxs = NULL, *ymaxs = NULL,
                   sx1, sy1, sx2, sy2, cx1, cy1, cx2, cy2, xt,
                   *cxnow = NULL, *cynow = NULL, *sxnow = NULL, *synow = NULL,
                   *xoutnow = NULL, *youtnow = NULL;
    int            cnparts, snparts, i, j, k, istat, *sintfound = NULL,
                   nhc, n1, chanc, ntotout, ntothout,
                   *chnow = NULL, *shnow = NULL, npoutnow, nctotal, ntmp1, ntmp2,
                   m, mm, l, coffset, *icoutnow = NULL, *ihoutnow = NULL;

    CSWPolyUtils   ply_utils_obj;
    CSWPolyDrivers  ply_drivers_obj;

    auto fscope = [&]() 
    {
        csw_Free (xpc);
        csw_Free (xminc);
        csw_Free (icoutnow);
        csw_Free (sintfound);
    };
    CSWScopeGuard  func_scope_guard (fscope);

    *cout = 0;

    cnparts = nc;
    snparts = ns;

    nhc = 0;
    for (i=0; i<nc; i++) {
        nhc += icompc[i];
    }

    xpc = (double **)csw_Malloc ((nhc + ns) * 2 * sizeof(double *));
    if (!xpc) {
        return -1;
    }
    ypc = xpc + nhc;
    xps = ypc + nhc;
    yps = xps + ns;

    xminc = (double *)csw_Malloc ((nhc + ns) * 4 * sizeof(double));
    if (!xminc) {
        return -1;
    }
    yminc = xminc + nhc;
    xmaxc = yminc + nhc;
    ymaxc = xmaxc + nhc;
    xmins = ymaxc + nhc;
    ymins = xmins + ns;
    xmaxs = ymins + ns;
    ymaxs = xmaxs + ns;

    i = (nhc + ns) * 10;
    if (i < 100) i = 1000;
    icoutnow = (int *)csw_Malloc (i * sizeof(int));
    if (!icoutnow) {
        return -1;
    }

    sintfound = (int *)csw_Malloc (ns * sizeof(int));
    if (!sintfound) {
        return -1;
    }
    memset (sintfound, 0, ns * sizeof(int));

    n1 = 0;
    for (i=0; i<nhc; i++) {
        xpc[i] = xc + n1;
        ypc[i] = yc + n1;
        n1 += iholec[i];
    }

    n1 = 0;
    for (i=0; i<ns; i++) {
        xps[i] = xs + n1;
        yps[i] = ys + n1;
        n1 += sholes[i];
    }

/*
    for each part of the clip polygon set,
    calculate the intersection with each source part
*/
    coffset = 0;
    ihoutnow = hout;
    xoutnow = xout;
    youtnow = yout;
    npoutnow = 0;
    nctotal = 0;
    nhc = 0;
    ntotout = 0;
    ntothout = 0;

    cxnow = xc;
    cynow = yc;
    chnow = iholec;
    chanc = 0;

    for (i=0; i<cnparts; i++) {

    /*
        get limits and reorient each clip hole
    */
        cx1 = 1.e30f;
        cy1 = 1.e30f;
        cx2 = -1.e30f;
        cy2 = -1.e30f;
        ply_utils_obj.ply_limits (cxnow, cynow, chnow, icompc[i],
                    xminc, yminc, xmaxc, ymaxc,
                    &cx1, &cy1, &cx2, &cy2);
        coffset = 0;
        for (k=0; k<icompc[i]; k++) {
            coffset += iholec[nhc];
            nhc++;
        }

    /*
        Orient the clip main component clockwise.
    */
        istat = ply_utils_obj.ply_orient (1, cxnow, cynow, chnow[0],
                            xminc[0], yminc[0], xmaxc[0], ymaxc[0]);
        if (istat >= 1) {
            err_obj.csw_SetErrNum (PLY_BADORIENT);
            return -1;
        }

    /*
        Orient the clip holes ccw.
    */
        for (k=chanc+1; k<chanc+icompc[i]; k++) {
            istat = ply_utils_obj.ply_orient (-1, xpc[k], ypc[k], iholec[k],
                                xminc[k], yminc[k], xmaxc[k], ymaxc[k]);
            if (istat >= 1) {
                err_obj.csw_SetErrNum (PLY_BADORIENT);
                return -1;
            }
        }

        chanc += icompc[i];
        xt = cx2 - cx1 + cy2 - cy1;
        xt /= 5000.f;
        xt /= 5000.f;
        ply_utils_obj.ply_setgraze (xt);

    /*
        clip each source part to this clip part
    */
        sxnow = xs;
        synow = ys;
        shnow = sholes;

        for (j=0; j<snparts; j++) {

        /*
            get limits and orient the main component clockwise
            (there are no holes in extra polygons)
        */
            sx1 = 1.e30f;
            sy1 = 1.e30f;
            sx2 = -1.e30f;
            sy2 = -1.e30f;
            ply_utils_obj.ply_limits (sxnow, synow, &(sholes[j]), 1,
                        xmins, ymins, xmaxs, ymaxs,
                        &sx1, &sy1, &sx2, &sy2);

            istat = ply_utils_obj.ply_orient (1, sxnow, synow, *shnow,
                                xmins[0], ymins[0], xmaxs[0], ymaxs[0]);
            if (istat >= 1) {
                err_obj.csw_SetErrNum (PLY_BADORIENT);
                return -1;
            }

        /*
            Calculate the intersecting components of the current clip
            and source polygons.  The output is appended to the previously
            calculated components.
        */
            ply_gridvec_obj.ply_setupvecgrids (cxnow, cynow, icompc[i], chnow,
                               sxnow, synow, 1, shnow);

            xt = (double)(max1);
            ply_utils_obj.ply_parms ('w', "maxpout", &xt);
            xt = (double)(max2);
            ply_utils_obj.ply_parms ('w', "maxhout", &xt);

            istat = ply_drivers_obj.ply_intcomps (err_obj,
                                  ply_gridvec_obj,
                                  sxnow, synow, 1, shnow,
                                  xps, yps, xmins, ymins, xmaxs, ymaxs,
                                  cxnow, cynow, icompc[i], chnow,
                                  xpc, ypc, xminc, yminc, xmaxc, ymaxc,
                                  xoutnow, youtnow, &npoutnow,
                                  icoutnow, ihoutnow,
                                  NULL, NULL, NULL, NULL, 0, 0);

            if (istat == -1) {
                err_obj.csw_SetErrNum (PLY_BADMALLOC);
                return -1;
            }
            if (istat == 1) {
                err_obj.csw_SetErrNum (PLY_WORKSIZE);
                return -1;
            }

        /*
            if no intersection found, try reversing clip and source
        */
            if (istat == 2) {
                ply_gridvec_obj.ply_SetSrcClipGrids (-1);
                istat = ply_drivers_obj.ply_intcomps (err_obj,
                                  ply_gridvec_obj,
                                  cxnow, cynow, icompc[i], chnow,
                                  xpc, ypc, xminc, yminc, xmaxc, ymaxc,
                                  sxnow, synow, 1, shnow,
                                  xps, yps, xmins, ymins, xmaxs, ymaxs,
                                  xoutnow, youtnow, &npoutnow,
                                  icoutnow, ihoutnow,
                                  NULL, NULL, NULL, NULL, 0, 0);
                ply_gridvec_obj.ply_SetSrcClipGrids (1);

            /*
                If there is no intersection with any clip component,
                the extra polygon needs to be output without modification.
                The sintfound array keeps track of this.
            */
                if (istat == 2) {
                    npoutnow = 0;
                }
                else {
                    sintfound[j] = 1;
                }
            }

        /*
            Increment the input and output pointers for the next
            clip/source polygon pair in the set.
        */
            nctotal += npoutnow;
            mm = 0;
            ntmp1 = 0;
            ntmp2 = 0;
            for (k=0; k<npoutnow; k++) {
                m = icoutnow[k];
                if (ntothout + m >= max2) {
                    return -1;
                }
                ntmp1 += m;
                for (l=0; l<m; l++) {
                    ntmp2 += ihoutnow[mm];
                    mm++;
                }
            }

            if (ntotout + ntmp2 >= max1) {
                return -1;
            }

            xoutnow += ntmp2;
            youtnow += ntmp2;
            ntotout += ntmp2;
            ihoutnow += ntmp1;
            ntothout += ntmp1;

            sxnow += sholes[j];
            synow += sholes[j];
            shnow++;

        }  /*  end of loop through source polygons for a clip polygon  */

    /*
        Increment pointers to the clip polygon data to
        define the next polygon in the clip polygon set
    */
        cxnow += coffset;
        cynow += coffset;
        chnow += icompc[i];

    }  /*  end of loop through clip polygons in the set  */

/*
    append any source components that did not intersect a clip
    polygon to the output.
*/
    sxnow = xs;
    synow = ys;
    for (i=0; i<ns; i++) {
        if (sintfound[i] == 0) {
            ply_utils_obj.ply_copy (sxnow, synow, sholes[i],
                      xoutnow, youtnow);
            xoutnow += sholes[i];
            youtnow += sholes[i];
            *ihoutnow = sholes[i];
            ihoutnow++;
            nctotal++;
        }
        sxnow += sholes[i];
        synow += sholes[i];
    }

    *cout = nctotal;

/*
    all done
*/
    return 1;

}  /*  end of private ProcessExtra function  */
